{"version":3,"file":"event-layout-utils.js","sources":["../../../src/vue/utils/event-layout-utils.ts"],"sourcesContent":["import dayjs from 'dayjs'\nimport utc from 'dayjs/plugin/utc'\nimport timezone from 'dayjs/plugin/timezone'\nimport isSameOrBefore from 'dayjs/plugin/isSameOrBefore'\nimport isSameOrAfter from 'dayjs/plugin/isSameOrAfter'\nimport type { CalendarEvent } from '../constants/calendar'\n\n// Extend dayjs with plugins\ndayjs.extend(utc)\ndayjs.extend(timezone)\ndayjs.extend(isSameOrBefore)\ndayjs.extend(isSameOrAfter)\n\n// Event layout interface for column-based positioning\nexport interface EventLayout {\n  event: CalendarEvent\n  column: number\n  columnSpan: number\n  totalColumns: number\n}\n\n// Check if two events overlap in time\nexport const eventsOverlap = (\n  a: CalendarEvent,\n  b: CalendarEvent,\n  timezone: string,\n): boolean => {\n  const aStart = dayjs(a.startTime).tz(timezone)\n  const aEnd = dayjs(a.endTime).tz(timezone)\n  const bStart = dayjs(b.startTime).tz(timezone)\n  const bEnd = dayjs(b.endTime).tz(timezone)\n  return aStart.isBefore(bEnd) && bStart.isBefore(aEnd)\n}\n\n// Find connected clusters of events (events connected through transitive overlaps)\n// Uses pre-sorting and adjacency list for O(n log n + n²) instead of O(n³)\nexport const findEventClusters = (\n  allEvents: CalendarEvent[],\n  timezone: string,\n): CalendarEvent[][] => {\n  if (allEvents.length === 0) return []\n\n  // Pre-sort events by start time for efficient overlap detection\n  const sortedEvents = [...allEvents].sort((a, b) => {\n    return dayjs(a.startTime).tz(timezone).diff(dayjs(b.startTime).tz(timezone))\n  })\n\n  // Build adjacency list: for each event, find which events it overlaps with\n  const adjacencyList = new Map<CalendarEvent, Set<CalendarEvent>>()\n  for (let i = 0; i < sortedEvents.length; i++) {\n    const eventI = sortedEvents[i]!\n    adjacencyList.set(eventI, new Set())\n    const eventAEnd = dayjs(eventI.endTime).tz(timezone)\n\n    // Only check events that start before this event ends (sorted by start time)\n    for (let j = i + 1; j < sortedEvents.length; j++) {\n      const eventJ = sortedEvents[j]!\n      const eventBStart = dayjs(eventJ.startTime).tz(timezone)\n      if (eventBStart.isSameOrAfter(eventAEnd)) break // No more overlaps possible\n\n      if (eventsOverlap(eventI, eventJ, timezone)) {\n        adjacencyList.get(eventI)!.add(eventJ)\n        if (!adjacencyList.has(eventJ)) {\n          adjacencyList.set(eventJ, new Set())\n        }\n        adjacencyList.get(eventJ)!.add(eventI)\n      }\n    }\n  }\n\n  const visited = new Set<CalendarEvent>()\n  const clusters: CalendarEvent[][] = []\n\n  for (const event of sortedEvents) {\n    if (visited.has(event)) continue\n\n    // BFS to find all events in this cluster using pre-built adjacency list\n    const cluster: CalendarEvent[] = []\n    const queue: CalendarEvent[] = [event]\n    let queueIndex = 0\n\n    while (queueIndex < queue.length) {\n      const current = queue[queueIndex++]!\n      if (visited.has(current)) continue\n\n      visited.add(current)\n      cluster.push(current)\n\n      // Add neighbors from adjacency list (O(1) lookup)\n      const neighbors = adjacencyList.get(current) || new Set()\n      for (const neighbor of neighbors) {\n        if (!visited.has(neighbor)) {\n          queue.push(neighbor)\n        }\n      }\n    }\n\n    // Sort cluster by start time, then by duration (longer first)\n    cluster.sort((a, b) => {\n      const startDiff = dayjs(a.startTime)\n        .tz(timezone)\n        .diff(dayjs(b.startTime).tz(timezone))\n      if (startDiff !== 0) return startDiff\n      const aDuration = dayjs(a.endTime).diff(dayjs(a.startTime))\n      const bDuration = dayjs(b.endTime).diff(dayjs(b.startTime))\n      return bDuration - aDuration\n    })\n\n    clusters.push(cluster)\n  }\n\n  return clusters\n}\n\n// Calculate event layouts for a cluster using column-based algorithm (Google Calendar style)\nexport const calculateClusterLayouts = (\n  cluster: CalendarEvent[],\n  timezone: string,\n): Map<CalendarEvent, EventLayout> => {\n  const layouts = new Map<CalendarEvent, EventLayout>()\n  const columns: dayjs.Dayjs[] = []\n  const eventColumnAssignments = new Map<CalendarEvent, number>()\n\n  // Assign each event in the cluster to a column\n  for (const event of cluster) {\n    const eventStart = dayjs(event.startTime).tz(timezone)\n\n    // Find the first available column\n    let assignedColumn = -1\n    for (let col = 0; col < columns.length; col++) {\n      if (columns[col]?.isSameOrBefore(eventStart)) {\n        assignedColumn = col\n        break\n      }\n    }\n\n    // If no column is available, create a new one\n    if (assignedColumn === -1) {\n      assignedColumn = columns.length\n      columns.push(dayjs(0))\n    }\n\n    // Update the column's end time\n    columns[assignedColumn] = dayjs(event.endTime).tz(timezone)\n    eventColumnAssignments.set(event, assignedColumn)\n  }\n\n  const totalColumns = columns.length\n\n  // Pre-compute which columns each event blocks to avoid repeated O(n) lookups\n  const eventsByColumn = new Map<number, CalendarEvent[]>()\n  for (let col = 0; col < totalColumns; col++) {\n    eventsByColumn.set(col, [])\n  }\n  for (const e of cluster) {\n    const eColumn = eventColumnAssignments.get(e)\n    if (eColumn !== undefined) {\n      eventsByColumn.get(eColumn)!.push(e)\n    }\n  }\n\n  // Calculate column span for each event\n  for (const event of cluster) {\n    const eventStart = dayjs(event.startTime).tz(timezone)\n    const eventEnd = dayjs(event.endTime).tz(timezone)\n    const eventColumn = eventColumnAssignments.get(event)!\n\n    // Calculate how far this event can expand to the right\n    let columnSpan = 1\n    for (let col = eventColumn + 1; col < totalColumns; col++) {\n      // Check if any event in this column overlaps with our event\n      const eventsInCol = eventsByColumn.get(col) || []\n      const columnBlocked = eventsInCol.some((other) => {\n        const otherStart = dayjs(other.startTime).tz(timezone)\n        const otherEnd = dayjs(other.endTime).tz(timezone)\n        return eventStart.isBefore(otherEnd) && otherStart.isBefore(eventEnd)\n      })\n      if (columnBlocked) break\n      columnSpan++\n    }\n\n    layouts.set(event, {\n      event,\n      column: eventColumn,\n      columnSpan,\n      totalColumns,\n    })\n  }\n\n  return layouts\n}\n\n// Generate a stable key for an event to use in Maps\nexport const getEventKey = (event: CalendarEvent): string => {\n  return `${event.startTime}|${event.endTime}|${event.title || ''}`\n}\n"],"names":["dayjs","utc","timezone","isSameOrBefore","isSameOrAfter","eventsOverlap","a","b","aStart","aEnd","bStart","bEnd","findEventClusters","allEvents","sortedEvents","adjacencyList","i","eventI","eventAEnd","j","eventJ","visited","clusters","event","cluster","queue","queueIndex","current","neighbors","neighbor","startDiff","aDuration","calculateClusterLayouts","layouts","columns","eventColumnAssignments","eventStart","assignedColumn","col","totalColumns","eventsByColumn","e","eColumn","eventEnd","eventColumn","columnSpan","other","otherStart","otherEnd","getEventKey"],"mappings":";;;;;AAQAA,EAAM,OAAOC,CAAG;AAChBD,EAAM,OAAOE,CAAQ;AACrBF,EAAM,OAAOG,CAAc;AAC3BH,EAAM,OAAOI,CAAa;AAWnB,MAAMC,IAAgB,CAC3BC,GACAC,GACAL,MACY;AACZ,QAAMM,IAASR,EAAMM,EAAE,SAAS,EAAE,GAAGJ,CAAQ,GACvCO,IAAOT,EAAMM,EAAE,OAAO,EAAE,GAAGJ,CAAQ,GACnCQ,IAASV,EAAMO,EAAE,SAAS,EAAE,GAAGL,CAAQ,GACvCS,IAAOX,EAAMO,EAAE,OAAO,EAAE,GAAGL,CAAQ;AACzC,SAAOM,EAAO,SAASG,CAAI,KAAKD,EAAO,SAASD,CAAI;AACtD,GAIaG,IAAoB,CAC/BC,GACAX,MACsB;AACtB,MAAIW,EAAU,WAAW,EAAG,QAAO,CAAA;AAGnC,QAAMC,IAAe,CAAC,GAAGD,CAAS,EAAE,KAAK,CAACP,GAAGC,MACpCP,EAAMM,EAAE,SAAS,EAAE,GAAGJ,CAAQ,EAAE,KAAKF,EAAMO,EAAE,SAAS,EAAE,GAAGL,CAAQ,CAAC,CAC5E,GAGKa,wBAAoB,IAAA;AAC1B,WAASC,IAAI,GAAGA,IAAIF,EAAa,QAAQE,KAAK;AAC5C,UAAMC,IAASH,EAAaE,CAAC;AAC7B,IAAAD,EAAc,IAAIE,GAAQ,oBAAI,IAAA,CAAK;AACnC,UAAMC,IAAYlB,EAAMiB,EAAO,OAAO,EAAE,GAAGf,CAAQ;AAGnD,aAASiB,IAAIH,IAAI,GAAGG,IAAIL,EAAa,QAAQK,KAAK;AAChD,YAAMC,IAASN,EAAaK,CAAC;AAE7B,UADoBnB,EAAMoB,EAAO,SAAS,EAAE,GAAGlB,CAAQ,EACvC,cAAcgB,CAAS,EAAG;AAE1C,MAAIb,EAAcY,GAAQG,GAAQlB,CAAQ,MACxCa,EAAc,IAAIE,CAAM,EAAG,IAAIG,CAAM,GAChCL,EAAc,IAAIK,CAAM,KAC3BL,EAAc,IAAIK,GAAQ,oBAAI,IAAA,CAAK,GAErCL,EAAc,IAAIK,CAAM,EAAG,IAAIH,CAAM;AAAA,IAEzC;AAAA,EACF;AAEA,QAAMI,wBAAc,IAAA,GACdC,IAA8B,CAAA;AAEpC,aAAWC,KAAST,GAAc;AAChC,QAAIO,EAAQ,IAAIE,CAAK,EAAG;AAGxB,UAAMC,IAA2B,CAAA,GAC3BC,IAAyB,CAACF,CAAK;AACrC,QAAIG,IAAa;AAEjB,WAAOA,IAAaD,EAAM,UAAQ;AAChC,YAAME,IAAUF,EAAMC,GAAY;AAClC,UAAIL,EAAQ,IAAIM,CAAO,EAAG;AAE1B,MAAAN,EAAQ,IAAIM,CAAO,GACnBH,EAAQ,KAAKG,CAAO;AAGpB,YAAMC,IAAYb,EAAc,IAAIY,CAAO,yBAAS,IAAA;AACpD,iBAAWE,KAAYD;AACrB,QAAKP,EAAQ,IAAIQ,CAAQ,KACvBJ,EAAM,KAAKI,CAAQ;AAAA,IAGzB;AAGA,IAAAL,EAAQ,KAAK,CAAClB,GAAGC,MAAM;AACrB,YAAMuB,IAAY9B,EAAMM,EAAE,SAAS,EAChC,GAAGJ,CAAQ,EACX,KAAKF,EAAMO,EAAE,SAAS,EAAE,GAAGL,CAAQ,CAAC;AACvC,UAAI4B,MAAc,EAAG,QAAOA;AAC5B,YAAMC,IAAY/B,EAAMM,EAAE,OAAO,EAAE,KAAKN,EAAMM,EAAE,SAAS,CAAC;AAE1D,aADkBN,EAAMO,EAAE,OAAO,EAAE,KAAKP,EAAMO,EAAE,SAAS,CAAC,IACvCwB;AAAA,IACrB,CAAC,GAEDT,EAAS,KAAKE,CAAO;AAAA,EACvB;AAEA,SAAOF;AACT,GAGaU,IAA0B,CACrCR,GACAtB,MACoC;AACpC,QAAM+B,wBAAc,IAAA,GACdC,IAAyB,CAAA,GACzBC,wBAA6B,IAAA;AAGnC,aAAWZ,KAASC,GAAS;AAC3B,UAAMY,IAAapC,EAAMuB,EAAM,SAAS,EAAE,GAAGrB,CAAQ;AAGrD,QAAImC,IAAiB;AACrB,aAASC,IAAM,GAAGA,IAAMJ,EAAQ,QAAQI;AACtC,UAAIJ,EAAQI,CAAG,GAAG,eAAeF,CAAU,GAAG;AAC5C,QAAAC,IAAiBC;AACjB;AAAA,MACF;AAIF,IAAID,MAAmB,OACrBA,IAAiBH,EAAQ,QACzBA,EAAQ,KAAKlC,EAAM,CAAC,CAAC,IAIvBkC,EAAQG,CAAc,IAAIrC,EAAMuB,EAAM,OAAO,EAAE,GAAGrB,CAAQ,GAC1DiC,EAAuB,IAAIZ,GAAOc,CAAc;AAAA,EAClD;AAEA,QAAME,IAAeL,EAAQ,QAGvBM,wBAAqB,IAAA;AAC3B,WAASF,IAAM,GAAGA,IAAMC,GAAcD;AACpC,IAAAE,EAAe,IAAIF,GAAK,EAAE;AAE5B,aAAWG,KAAKjB,GAAS;AACvB,UAAMkB,IAAUP,EAAuB,IAAIM,CAAC;AAC5C,IAAIC,MAAY,UACdF,EAAe,IAAIE,CAAO,EAAG,KAAKD,CAAC;AAAA,EAEvC;AAGA,aAAWlB,KAASC,GAAS;AAC3B,UAAMY,IAAapC,EAAMuB,EAAM,SAAS,EAAE,GAAGrB,CAAQ,GAC/CyC,IAAW3C,EAAMuB,EAAM,OAAO,EAAE,GAAGrB,CAAQ,GAC3C0C,IAAcT,EAAuB,IAAIZ,CAAK;AAGpD,QAAIsB,IAAa;AACjB,aAASP,IAAMM,IAAc,GAAGN,IAAMC,KAGd,EADFC,EAAe,IAAIF,CAAG,KAAK,CAAA,GACb,KAAK,CAACQ,MAAU;AAChD,YAAMC,IAAa/C,EAAM8C,EAAM,SAAS,EAAE,GAAG5C,CAAQ,GAC/C8C,IAAWhD,EAAM8C,EAAM,OAAO,EAAE,GAAG5C,CAAQ;AACjD,aAAOkC,EAAW,SAASY,CAAQ,KAAKD,EAAW,SAASJ,CAAQ;AAAA,IACtE,CAAC,GAPiDL;AASlD,MAAAO;AAGF,IAAAZ,EAAQ,IAAIV,GAAO;AAAA,MACjB,OAAAA;AAAA,MACA,QAAQqB;AAAA,MACR,YAAAC;AAAA,MACA,cAAAN;AAAA,IAAA,CACD;AAAA,EACH;AAEA,SAAON;AACT,GAGagB,IAAc,CAAC1B,MACnB,GAAGA,EAAM,SAAS,IAAIA,EAAM,OAAO,IAAIA,EAAM,SAAS,EAAE;"}