{"version":3,"file":"DailyCalendarView.vue2.js","sources":["../../../../src/vue/components/calendar/DailyCalendarView.vue"],"sourcesContent":["<template>\n  <div class=\"primary-card\">\n    <div v-if=\"!isReady || timeSlots.length === 0\" class=\"daily-calendar\">\n      <div style=\"padding: 2rem; text-align: center\">Loading calendar...</div>\n    </div>\n    <div v-else class=\"daily-calendar\">\n      <div v-for=\"(slot, index) in timeSlots\" :key=\"index\" class=\"time-slot\">\n        <div class=\"time-label\">{{ slot.time }}</div>\n        <div class=\"time-content\">\n          <div class=\"hour-line\" />\n          <div\n            v-for=\"(event, eventIndex) in getEventsForTimeSlot(slot.hour)\"\n            :key=\"eventIndex\"\n            class=\"calendar-event-wrapper\"\n            :style=\"getWrapperStyle(event)\"\n          >\n            <div class=\"calendar-event-item\" :style=\"getItemStyle(event)\">\n              <div class=\"event-title\">\n                {{ event.title }}\n              </div>\n              <div>\n                <EventTimeRange\n                  :start-time=\"event.startTime\"\n                  :end-time=\"event.endTime\"\n                  :locale=\"props.locale\"\n                  :timezone=\"props.timezone\"\n                />\n              </div>\n            </div>\n          </div>\n        </div>\n      </div>\n      <div\n        v-if=\"showCurrentTimeIndicator\"\n        class=\"current-time-indicator\"\n        :style=\"{ top: `${currentTimePosition}%` }\"\n      />\n    </div>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport { ref, watch, computed } from 'vue'\nimport EventTimeRange from './EventTimeRange.vue'\nimport type { CalendarEvent, TimeSlot } from '../../constants/calendar'\nimport {\n  type EventLayout,\n  findEventClusters,\n  calculateClusterLayouts,\n} from '../../utils/event-layout-utils'\nimport dayjs from 'dayjs'\nimport utc from 'dayjs/plugin/utc'\nimport dayJsTimezone from 'dayjs/plugin/timezone'\nimport isSameOrBefore from 'dayjs/plugin/isSameOrBefore'\nimport isSameOrAfter from 'dayjs/plugin/isSameOrAfter'\n\ndayjs.extend(utc)\ndayjs.extend(dayJsTimezone)\ndayjs.extend(isSameOrBefore)\ndayjs.extend(isSameOrAfter)\n\ninterface Props {\n  timezone?: string\n  now: Date\n  events: CalendarEvent[]\n  locale: string\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  timezone: 'UTC',\n})\n\nconst timeSlots = ref<TimeSlot[]>([])\nconst isReady = ref(false)\n\nconst now = computed(() => props.now)\nconst events = computed(() => props.events)\n\n// Calculate current hour info - memoized for performance\nconst currentHourInfo = computed(() => {\n  const currentHour = parseInt(\n    new Date(now.value).toLocaleString('en-US', {\n      hour: 'numeric',\n      hour12: false,\n      timeZone: props.timezone,\n    }),\n  )\n  return {\n    current: currentHour,\n    start: currentHour - 1,\n    windowStart: (currentHour - 2 + 24) % 24,\n  }\n})\n\n// Pre-computed event map for better performance\nconst eventMap = computed(() => {\n  if (!events.value) return new Map()\n\n  const map = new Map<number, CalendarEvent[]>()\n  const today = dayjs(now.value).tz(props.timezone)\n\n  events.value.forEach((event) => {\n    const eventStart = dayjs(event.startTime).tz(props.timezone)\n\n    // Only include events for today\n    if (eventStart.isSame(today, 'day')) {\n      const eventHour = eventStart.hour()\n\n      if (!map.has(eventHour)) {\n        map.set(eventHour, [])\n      }\n      map.get(eventHour)!.push(event)\n    }\n  })\n\n  return map\n})\n\n// Calculate event layouts using a column-based algorithm (Google Calendar style)\nconst eventLayouts = computed(() => {\n  const allEvents = getAllEventsForToday.value\n  if (allEvents.length === 0) return new Map<CalendarEvent, EventLayout>()\n\n  const layouts = new Map<CalendarEvent, EventLayout>()\n  const clusters = findEventClusters(allEvents, props.timezone)\n\n  for (const cluster of clusters) {\n    const clusterLayouts = calculateClusterLayouts(cluster, props.timezone)\n    for (const [event, layout] of clusterLayouts) {\n      layouts.set(event, layout)\n    }\n  }\n\n  return layouts\n})\n\nconst getEventLayout = (\n  event: CalendarEvent,\n): { index: number; total: number; span: number } => {\n  const layout = eventLayouts.value.get(event)\n  if (!layout) {\n    return { index: 0, total: 1, span: 1 }\n  }\n  return {\n    index: layout.column,\n    total: layout.totalColumns,\n    span: layout.columnSpan,\n  }\n}\n\nconst generateTimeSlots = async () => {\n  try {\n    const userLocale = props.locale\n\n    const slots: TimeSlot[] = []\n    const currentHour = currentHourInfo.value.current\n\n    // Calculate dynamic 12-hour window based on current time\n    // Constraints: 12 slots, ending at 12:00 AM (midnight)\n    let startHour: number\n\n    if (currentHour > 12) {\n      // Afternoon/Evening: Show window ending at midnight\n      // Always show 11 hours before midnight to midnight (1:00 PM to 12:00 AM)\n      startHour = 13 // 1:00 PM\n    } else {\n      // Morning: Show window ending at midnight of the same day\n      // For current time X, show X to X+11 (ending at midnight)\n      startHour = currentHour\n    }\n\n    // Generate slots for the 12-hour window\n    for (let i = 0; i < 12; i++) {\n      const hour = (startHour + i) % 24\n\n      // Use toLocaleTimeString for proper formatting\n      const baseDate = new Date(now.value)\n      baseDate.setHours(hour, 0, 0, 0)\n      const timeString = baseDate.toLocaleTimeString(userLocale, {\n        hour: 'numeric',\n        minute: '2-digit',\n      })\n\n      slots.push({\n        time: timeString,\n        hour,\n      })\n    }\n\n    timeSlots.value = slots\n    isReady.value = true\n  } catch (error) {\n    console.error('Error generating time slots:', error)\n    // Fallback to simple time slots if locale fetch fails\n    const slots: TimeSlot[] = []\n    const currentHour = currentHourInfo.value.current\n\n    // Calculate dynamic 12-hour window based on current time\n    let startHour: number\n\n    if (currentHour > 12) {\n      // Afternoon/Evening: Show window ending at midnight\n      startHour = 13 // 1:00 PM\n    } else {\n      // Morning: Show window ending at midnight of the same day\n      startHour = currentHour\n    }\n\n    for (let i = 0; i < 12; i++) {\n      const hour = (startHour + i) % 24\n\n      // Fix the 12-hour format to properly show 12 AM\n      const formattedHour = hour === 0 ? 12 : hour % 12 || 12\n      const ampm = hour < 12 ? 'AM' : 'PM'\n\n      slots.push({\n        time: `${formattedHour}:00 ${ampm}`,\n        hour,\n      })\n    }\n    timeSlots.value = slots\n    isReady.value = true\n  }\n}\n\n// Get events that START in a specific time slot (to avoid duplicate rendering)\nconst getEventsForTimeSlot = (hour: number): CalendarEvent[] => {\n  return eventMap.value.get(hour) || []\n}\n\n// Get all events for today (used for overlap calculations)\nconst getAllEventsForToday = computed(() => {\n  const today = dayjs(now.value).tz(props.timezone)\n  return events.value.filter((event) => {\n    return dayjs(event.startTime).tz(props.timezone).isSame(today, 'day')\n  })\n})\n\n// Memoized event style computation\nconst eventStyleCache = new Map<string, Record<string, string>>()\n\n// Get wrapper style for an event (positioning only) - with caching for better performance\nconst getWrapperStyle = (event: CalendarEvent): Record<string, string> => {\n  // Get layout for this event using column-based algorithm (Google Calendar style)\n  const layout = getEventLayout(event)\n\n  // Create cache key that includes layout information to prevent collisions\n  // for events with identical start/end/backgroundColor but different positions\n  const cacheKey = `wrapper-${event.startTime}-${event.endTime}-${layout.index}-${layout.total}`\n\n  if (eventStyleCache.has(cacheKey)) {\n    return eventStyleCache.get(cacheKey)!\n  }\n\n  const startTime = dayjs(event.startTime).tz(props.timezone)\n  const endTime = dayjs(event.endTime).tz(props.timezone)\n\n  const startMinutes = startTime.minute()\n  const topOffset = startMinutes === 0 ? 50 : (startMinutes / 60) * 100 + 50\n\n  // Calculate duration using dayjs\n  const duration = endTime.diff(startTime, 'minute', true)\n  const durationHours = duration / 60\n\n  // Calculate the raw height\n  const rawHeight = durationHours * 100\n\n  // Determine the maximum visible height based on the last time slot\n  const lastVisibleHour =\n    timeSlots.value[timeSlots.value.length - 1]?.hour || 23\n\n  // For events that span across midnight, ensure they extend to at least touch the 12:00 AM line\n  let maxVisibleHeight: number\n  if (endTime.date() !== startTime.date()) {\n    // Event spans across midnight, ensure it extends to midnight (hour 0)\n    maxVisibleHeight = (24 - startTime.hour()) * 100\n  } else {\n    // Event is within the same day\n    maxVisibleHeight = (lastVisibleHour - startTime.hour()) * 100\n  }\n\n  // Limit the height to the maximum visible height\n  const height = Math.min(rawHeight, maxVisibleHeight)\n\n  // Add minimal gap between adjacent events (like Google Calendar)\n  // Reduce height by a small amount to create visual separation\n  const eventGap = 4 // 4% gap between events\n  const adjustedHeight = Math.max(height - eventGap, height * 0.9) // Ensure height doesn't go below 90% of original\n\n  // Calculate width and left position based on column layout\n  // Google Calendar style: events in earlier columns visually overlap into later columns\n  const columnWidth = 100 / layout.total\n  const eventSpan = layout.span && layout.span > 0 ? layout.span : 1\n  const baseWidth = columnWidth * eventSpan\n  const left = layout.index * columnWidth\n\n  // Events overlap into the next column's space (except the last column)\n  // overlapRatio controls how much of the next column's space to overlap into\n  const overlapRatio = 0.7\n  const isLastColumn = layout.index + eventSpan >= layout.total\n  const overlapBonus = isLastColumn ? 0 : columnWidth * overlapRatio\n  const width = baseWidth + overlapBonus\n\n  // Z-index: higher column numbers appear on top (base z-index of 2 from SCSS)\n  const zIndex = 2 + layout.index\n\n  // Create the wrapper style object (positioning only)\n  const wrapperStyle: Record<string, string> = {\n    top: `${topOffset}%`,\n    height: `${adjustedHeight}%`,\n    width: `${width}%`,\n    left: `${left}%`,\n    'z-index': `${zIndex}`,\n  }\n\n  // Cache the result\n  eventStyleCache.set(cacheKey, wrapperStyle)\n\n  // Limit cache size to prevent memory leaks\n  if (eventStyleCache.size > 100) {\n    const firstKey = eventStyleCache.keys().next().value\n    if (firstKey) {\n      eventStyleCache.delete(firstKey)\n    }\n  }\n\n  return wrapperStyle\n}\n\n// Get item style for an event (background-color only)\nconst getItemStyle = (event: CalendarEvent): Record<string, string> => {\n  if (event.backgroundColor) {\n    return { 'background-color': event.backgroundColor }\n  }\n  return {}\n}\n\n// Clear style cache when events change\nwatch(\n  events,\n  () => {\n    eventStyleCache.clear()\n  },\n  { deep: true },\n)\n\n// Calculate current time position for the red line\nconst currentTimePosition = computed(() => {\n  if (timeSlots.value.length === 0) return 0\n\n  const currentHour = parseInt(\n    now.value.toLocaleString('en-US', {\n      hour: 'numeric',\n      hour12: false,\n      timeZone: props.timezone,\n    }),\n  )\n  const currentMinute = now.value.getMinutes()\n\n  // Find the time slot that contains the current hour\n  const currentSlotIndex = timeSlots.value.findIndex(\n    (slot) => slot.hour === currentHour,\n  )\n\n  if (currentSlotIndex === -1) return -1 // Hide indicator if current time is not in visible range\n\n  // Calculate the percentage position within the current hour\n  // Add 45 minutes to move the line further down\n  const minutePercentage = (currentMinute + 45) / 60\n\n  // Calculate position as percentage of total visible time slots\n  const position =\n    ((currentSlotIndex + minutePercentage) / timeSlots.value.length) * 100\n\n  return Math.max(0, Math.min(100, position))\n})\n\n// Check if current time indicator should be visible\nconst showCurrentTimeIndicator = computed(() => {\n  return currentTimePosition.value >= 0 && currentTimePosition.value <= 100\n})\n\nwatch([now, () => props.timezone, currentHourInfo], generateTimeSlots, {\n  immediate: true,\n})\n\n// Update current time position every minute for smooth movement\nwatch(\n  now,\n  () => {\n    // Force reactivity update for current time position\n    // The computed property will automatically recalculate\n  },\n  { immediate: true },\n)\n</script>\n\n<style scoped lang=\"scss\">\n@use '../../styles/calendar/daily-calendar-view';\n</style>\n"],"names":["dayjs","utc","dayJsTimezone","isSameOrBefore","isSameOrAfter","props","__props","timeSlots","ref","isReady","now","computed","events","currentHourInfo","currentHour","eventMap","map","today","event","eventStart","eventHour","eventLayouts","allEvents","getAllEventsForToday","layouts","clusters","findEventClusters","cluster","clusterLayouts","calculateClusterLayouts","layout","getEventLayout","generateTimeSlots","userLocale","slots","startHour","i","hour","baseDate","timeString","error","formattedHour","ampm","getEventsForTimeSlot","eventStyleCache","getWrapperStyle","cacheKey","startTime","endTime","startMinutes","topOffset","rawHeight","lastVisibleHour","maxVisibleHeight","height","adjustedHeight","columnWidth","eventSpan","baseWidth","left","overlapBonus","width","zIndex","wrapperStyle","firstKey","getItemStyle","watch","currentTimePosition","currentMinute","currentSlotIndex","slot","minutePercentage","position","showCurrentTimeIndicator","_openBlock","_createElementBlock","_hoisted_1","_hoisted_2","_cache","_createElementVNode","_hoisted_3","_Fragment","_renderList","index","_hoisted_4","_toDisplayString","_hoisted_5","eventIndex","_normalizeStyle","_hoisted_6","_createVNode","EventTimeRange"],"mappings":"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"}