{"version":3,"file":"locale.js","sources":["../../src/utils/locale.ts"],"sourcesContent":["import tzlookup from '@photostructure/tz-lookup'\nimport clm from 'country-locale-map'\nimport { getNearestCity } from 'offline-geocode-city'\nimport { getSettingWithDefault } from './settings.js'\nimport { getMetadata } from './metadata.js'\n\n/**\n * Validate timezone using native Intl API\n */\nfunction isValidTimezone(timezone: string): boolean {\n  try {\n    new Intl.DateTimeFormat('en-US', { timeZone: timezone })\n    return true\n  } catch {\n    return false\n  }\n}\n\n/**\n * Validate locale using native Intl API\n * Ensures the resolved locale's language code matches the requested locale\n */\nfunction isValidLocale(locale: string): boolean {\n  // Basic format validation: should be at least 2 characters\n  // and not end with a hyphen\n  if (!locale || locale.length < 2 || locale.endsWith('-')) {\n    return false\n  }\n\n  // Language code should be 2-3 characters, followed by optional region/script\n  const localeRegex = /^[a-z]{2,3}(-[a-z]{2,})*$/i\n  if (!localeRegex.test(locale)) {\n    return false\n  }\n\n  try {\n    const formatter = new Intl.DateTimeFormat(locale)\n    const resolved = formatter.resolvedOptions().locale\n    // Check if the resolved locale's language code matches the requested one\n    // e.g., 'zh-CN' → language 'zh', 'en-US' → language 'en'\n    const requestedLanguage = locale.toLowerCase().split('-')[0]\n    const resolvedLanguage = resolved.toLowerCase().split('-')[0]\n\n    if (requestedLanguage !== resolvedLanguage) {\n      return false\n    }\n\n    // If request includes a region/script, verify it's preserved in resolution\n    // This catches cases like 'en-INVALID' resolving to 'en'\n    const requestedParts = locale.toLowerCase().split('-')\n    if (requestedParts.length > 1) {\n      const resolvedParts = resolved.toLowerCase().split('-')\n      // If we requested more than just language, the resolved should have similar depth\n      // (or not drop the requested parts entirely)\n      if (resolvedParts.length < requestedParts.length) {\n        return false\n      }\n    }\n\n    return true\n  } catch {\n    return false\n  }\n}\n\n/**\n * Resolve timezone configuration with fallback chain\n * Fallback order: override setting (validated) → GPS-based detection → 'UTC'\n */\nexport async function getTimeZone(): Promise<string> {\n  // Priority 1: Use override setting if provided and valid\n  const overrideTimezone = getSettingWithDefault<string>(\n    'override_timezone',\n    '',\n  )\n  if (overrideTimezone) {\n    // Validate using native Intl API\n    if (isValidTimezone(overrideTimezone)) {\n      return overrideTimezone\n    }\n    console.warn(\n      `Invalid timezone override: \"${overrideTimezone}\", falling back to GPS detection`,\n    )\n  }\n\n  try {\n    const [latitude, longitude] = getMetadata().coordinates\n    return tzlookup(latitude, longitude)\n  } catch (error) {\n    console.warn('Failed to get timezone from coordinates, using UTC:', error)\n    return 'UTC'\n  }\n}\n\n/**\n * Resolve locale configuration with fallback chain\n * Fallback order: override setting (validated) → GPS-based detection → browser locale → 'en'\n */\nexport async function getLocale(): Promise<string> {\n  // Priority 1: Use override setting if provided and valid\n  const overrideLocale = getSettingWithDefault<string>('override_locale', '')\n  if (overrideLocale) {\n    const normalizedLocale = overrideLocale.replaceAll('_', '-')\n    // Validate the override locale\n    if (isValidLocale(normalizedLocale)) {\n      return normalizedLocale\n    }\n    console.warn(\n      `Invalid locale override: \"${overrideLocale}\", falling back to GPS detection`,\n    )\n  }\n\n  const [lat, lng] = getMetadata().coordinates\n\n  const defaultLocale =\n    (navigator?.languages?.length\n      ? navigator.languages[0]\n      : navigator.language) || 'en'\n\n  try {\n    const data = await getNearestCity(lat, lng)\n    const countryCode = data.countryIso2.toUpperCase()\n\n    const locale = clm.getLocaleByAlpha2(countryCode) || defaultLocale\n    return locale.replace('_', '-')\n  } catch (error) {\n    console.warn('Failed to get locale from coordinates, using default:', error)\n    return defaultLocale\n  }\n}\n\n/**\n * Format coordinates into a human-readable string\n * Example: \"37.3861° N, 122.0839° W\"\n */\nexport function formatCoordinates(coordinates: [number, number]): string {\n  const [latitude, longitude] = coordinates\n\n  const latString = `${Math.abs(latitude).toFixed(4)}\\u00B0`\n  const latDirection = latitude > 0 ? 'N' : 'S'\n  const lngString = `${Math.abs(longitude).toFixed(4)}\\u00B0`\n  const lngDirection = longitude > 0 ? 'E' : 'W'\n\n  return `${latString} ${latDirection}, ${lngString} ${lngDirection}`\n}\n\n/**\n * Format a date in a locale-aware way.\n *\n * Examples:\n * - \"December 25, 2023\" in en-US\n * - \"25 December 2023\" in en-GB\n * - \"2023年12月25日\" in ja-JP\n * - \"25.12.2023\" in de-DE\n *\n * By default, formats as a full date (year, month, day). Callers can\n * override or extend the formatting via the `options` parameter.\n */\nexport function formatLocalizedDate(\n  date: Date,\n  locale: string,\n  options?: Intl.DateTimeFormatOptions,\n): string {\n  const baseOptions: Intl.DateTimeFormatOptions = {\n    year: 'numeric',\n    month: 'long',\n    day: 'numeric',\n  }\n\n  try {\n    const formatter = new Intl.DateTimeFormat(locale, {\n      ...baseOptions,\n      ...options,\n    })\n    return formatter.format(date)\n  } catch {\n    // Fallback to a safe default for unrecognized locales\n    const fallbackFormatter = new Intl.DateTimeFormat('en-US', {\n      ...baseOptions,\n      ...options,\n    })\n    return fallbackFormatter.format(date)\n  }\n}\n\n/**\n * Get localized day names (Sunday-Saturday)\n * Returns both full and short forms\n */\nexport function getLocalizedDayNames(locale: string): {\n  full: string[]\n  short: string[]\n} {\n  const full: string[] = []\n  const short: string[] = []\n\n  // Find the first Sunday of the current year\n  const now = new Date()\n  const year = now.getFullYear()\n  const firstDay = new Date(Date.UTC(year, 0, 1))\n  const dayOfWeek = firstDay.getUTCDay() // 0 = Sunday, 1 = Monday, etc.\n\n  // Calculate offset to get to the first Sunday\n  const offset = dayOfWeek === 0 ? 0 : 7 - dayOfWeek\n  const firstSunday = new Date(Date.UTC(year, 0, 1 + offset))\n\n  for (let i = 0; i < 7; i++) {\n    const date = new Date(firstSunday)\n    date.setUTCDate(firstSunday.getUTCDate() + i)\n\n    full.push(date.toLocaleDateString(locale, { weekday: 'long' }))\n    short.push(date.toLocaleDateString(locale, { weekday: 'short' }))\n  }\n\n  return { full, short }\n}\n\n/**\n * Get localized month names (January-December)\n * Returns both full and short forms\n */\nexport function getLocalizedMonthNames(locale: string): {\n  full: string[]\n  short: string[]\n} {\n  const full: string[] = []\n  const short: string[] = []\n\n  // Iterate through each month of the current year\n  const now = new Date()\n  const year = now.getFullYear()\n\n  for (let i = 0; i < 12; i++) {\n    const date = new Date(year, i, 1)\n\n    full.push(date.toLocaleDateString(locale, { month: 'long' }))\n    short.push(date.toLocaleDateString(locale, { month: 'short' }))\n  }\n\n  return { full, short }\n}\n\n/**\n * Detect if a locale uses 12-hour or 24-hour format\n */\nexport function detectHourFormat(locale: string): 'hour12' | 'hour24' {\n  try {\n    const formatter = new Intl.DateTimeFormat(locale, {\n      hour: 'numeric',\n    })\n\n    return formatter.resolvedOptions().hour12 ? 'hour12' : 'hour24'\n  } catch {\n    // Fallback to 24-hour for unrecognized locales\n    return 'hour24'\n  }\n}\n\n/**\n * Extract time parts from a DateTimeFormat formatter\n */\nfunction extractTimePartsFromFormatter(\n  date: Date,\n  formatter: Intl.DateTimeFormat,\n): {\n  hour: string\n  minute: string\n  second: string\n  dayPeriod?: string\n} {\n  const parts = formatter.formatToParts(date)\n  const partMap: Record<string, string> = {}\n\n  parts.forEach((part) => {\n    if (part.type !== 'literal') {\n      partMap[part.type] = part.value\n    }\n  })\n\n  return {\n    hour: partMap.hour || '00',\n    minute: partMap.minute || '00',\n    second: partMap.second || '00',\n    dayPeriod: partMap.dayPeriod,\n  }\n}\n\n/**\n * Get locale extension for numeral system based on language\n * This enables locale-specific number representations (e.g., Thai numerals, Chinese numerals)\n * Uses Intl.Locale API to robustly handle existing extensions\n */\nfunction getLocaleWithNumeralSystem(locale: string): string {\n  const language = locale.toLowerCase().split('-')[0]\n\n  // Map of languages to their numeral system extensions\n  const numeralSystemMap: Record<string, string> = {\n    th: 'thai', // Thai numerals: ๐๑๒๓๔๕๖๗๘๙\n    zh: 'hanidec', // Chinese numerals: 〇一二三四五六七八九\n  }\n\n  const numeralSystem = numeralSystemMap[language]\n  if (!numeralSystem) {\n    return locale\n  }\n\n  try {\n    // Use Intl.Locale API to robustly handle existing extensions\n    // This properly merges extensions instead of creating duplicates\n    const localeObj = new Intl.Locale(locale, {\n      numberingSystem: numeralSystem,\n    })\n    return localeObj.toString()\n  } catch (error) {\n    // Fallback to original locale if Intl.Locale fails\n    console.warn(`Failed to apply numeral system to locale \"${locale}\":`, error)\n    return locale\n  }\n}\n\n/**\n * Format time with locale and timezone awareness\n * Returns structured time parts for flexible composition\n */\nexport function formatTime(\n  date: Date,\n  locale: string,\n  timezone: string,\n  options?: {\n    hour12?: boolean\n  },\n): {\n  hour: string\n  minute: string\n  second: string\n  dayPeriod?: string\n  formatted: string\n} {\n  try {\n    // Determine hour format if not explicitly provided\n    const hour12 = options?.hour12 ?? detectHourFormat(locale) === 'hour12'\n\n    // Get locale with numeral system extension if applicable\n    const localeWithNumerals = getLocaleWithNumeralSystem(locale)\n\n    // Format with Intl API for proper localization\n    const formatter = new Intl.DateTimeFormat(localeWithNumerals, {\n      hour: '2-digit',\n      minute: '2-digit',\n      second: '2-digit',\n      hour12,\n      timeZone: timezone,\n    })\n\n    const timeParts = extractTimePartsFromFormatter(date, formatter)\n\n    return {\n      ...timeParts,\n      formatted: formatter.format(date),\n    }\n  } catch (error) {\n    console.warn(\n      `Failed to format time for locale \"${locale}\" and timezone \"${timezone}\":`,\n      error,\n    )\n    // Fallback to UTC in English\n    const fallbackFormatter = new Intl.DateTimeFormat('en', {\n      hour: '2-digit',\n      minute: '2-digit',\n      second: '2-digit',\n      hour12: false,\n      timeZone: 'UTC',\n    })\n\n    const timeParts = extractTimePartsFromFormatter(date, fallbackFormatter)\n\n    return {\n      ...timeParts,\n      formatted: fallbackFormatter.format(date),\n    }\n  }\n}\n"],"names":["isValidLocale","locale","resolved","requestedLanguage","resolvedLanguage","requestedParts","getLocale","overrideLocale","getSettingWithDefault","normalizedLocale","lat","lng","getMetadata","defaultLocale","countryCode","getNearestCity","clm","error","formatCoordinates","coordinates","latitude","longitude","latString","latDirection","lngString","lngDirection"],"mappings":";;;;;AAsBA,SAASA,EAAcC,GAAyB;AAS9C,MANI,CAACA,KAAUA,EAAO,SAAS,KAAKA,EAAO,SAAS,GAAG,KAMnD,CADgB,6BACH,KAAKA,CAAM;AAC1B,WAAO;AAGT,MAAI;AAEF,UAAMC,IADY,IAAI,KAAK,eAAeD,CAAM,EACrB,gBAAA,EAAkB,QAGvCE,IAAoBF,EAAO,YAAA,EAAc,MAAM,GAAG,EAAE,CAAC,GACrDG,IAAmBF,EAAS,YAAA,EAAc,MAAM,GAAG,EAAE,CAAC;AAE5D,QAAIC,MAAsBC;AACxB,aAAO;AAKT,UAAMC,IAAiBJ,EAAO,YAAA,EAAc,MAAM,GAAG;AACrD,WAAI,EAAAI,EAAe,SAAS,KACJH,EAAS,YAAA,EAAc,MAAM,GAAG,EAGpC,SAASG,EAAe;AAAA,EAM9C,QAAQ;AACN,WAAO;AAAA,EACT;AACF;AAmCA,eAAsBC,IAA6B;AAEjD,QAAMC,IAAiBC,EAA8B,mBAAmB,EAAE;AAC1E,MAAID,GAAgB;AAClB,UAAME,IAAmBF,EAAe,WAAW,KAAK,GAAG;AAE3D,QAAIP,EAAcS,CAAgB;AAChC,aAAOA;AAET,YAAQ;AAAA,MACN,6BAA6BF,CAAc;AAAA,IAAA;AAAA,EAE/C;AAEA,QAAM,CAACG,GAAKC,CAAG,IAAIC,IAAc,aAE3BC,KACH,WAAW,WAAW,SACnB,UAAU,UAAU,CAAC,IACrB,UAAU,aAAa;AAE7B,MAAI;AAEF,UAAMC,KADO,MAAMC,EAAeL,GAAKC,CAAG,GACjB,YAAY,YAAA;AAGrC,YADeK,EAAI,kBAAkBF,CAAW,KAAKD,GACvC,QAAQ,KAAK,GAAG;AAAA,EAChC,SAASI,GAAO;AACd,mBAAQ,KAAK,yDAAyDA,CAAK,GACpEJ;AAAA,EACT;AACF;AAMO,SAASK,EAAkBC,GAAuC;AACvE,QAAM,CAACC,GAAUC,CAAS,IAAIF,GAExBG,IAAY,GAAG,KAAK,IAAIF,CAAQ,EAAE,QAAQ,CAAC,CAAC,KAC5CG,IAAeH,IAAW,IAAI,MAAM,KACpCI,IAAY,GAAG,KAAK,IAAIH,CAAS,EAAE,QAAQ,CAAC,CAAC,KAC7CI,IAAeJ,IAAY,IAAI,MAAM;AAE3C,SAAO,GAAGC,CAAS,IAAIC,CAAY,KAAKC,CAAS,IAAIC,CAAY;AACnE;"}